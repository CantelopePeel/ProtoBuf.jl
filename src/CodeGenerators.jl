module CodeGenerators

import ..Parsers
import Pkg
import Dates

const JULIA_RESERVED_KEYWORDS = Set{String}([
    "baremodule", "begin", "break", "catch", "const", "continue", "do", "else", "elseif", "end",
    "export", "false", "finally", "for", "function", "global", "if", "import", "let", "local", 
    "macro", "module", "quote", "return", "struct", "true", "try", "using", "while",
    "abstract", "ccall", "typealias", "type", "bitstype", "importall", "immutable", "Type", "Enum", 
    "Any", "DataType", "Base", "Core", "InteractiveUtils", "Set", "Method", "include", "eval", "ans",
    # TODO: add all subtypes(Any) from a fresh julia session?
    "OneOf",
])

function safename(name::AbstractString)
    dot_pos = findfirst(==('.'), name)
    if name in JULIA_RESERVED_KEYWORDS
        return string("var\"#", name, '"')
    elseif isnothing(dot_pos) && !('#' in name)
        return name
    elseif dot_pos == 1
        return string("@__MODULE__.", safename(@view name[2:end]))
    else
        return string("var\"", name, '"')
    end
end

function translate_import_path(p::Parsers.ProtoFile)
    assumed_file_relpath = joinpath(replace(p.preamble.identifier, '.' => '/'), "")
    relpaths = String[]
    for i in p.preamble.imports
        rel_path_to_module = relpath(dirname(i.name), assumed_file_relpath)
        translated_module_name = Parsers.proto_module_name(i.name)
        push!(relpaths, joinpath(rel_path_to_module, translated_module_name))
    end
    return relpaths
end

codegen(t::Parsers.AbstractProtoType, p::Parsers.ProtoFile) = codegen(stdin, t, p)

_is_repeated_field(f::Parsers.AbstractProtoFieldType) = f.label == Parsers.REPEATED
_is_repeated_field(::Parsers.OneOfType) = false

function codegen(io, t::Parsers.MessageType, p::Parsers.ProtoFile)
    print(io, "struct ", safename(t.name), length(t.fields) > 0 ? "" : ' ')
    length(t.fields) > 0 && println(io)
    for field in t.fields
        if _is_repeated_field(field)
            println(io, "    ", jl_fieldname(field), "::Vector{", jltypename(field, p), '}')
        else
            println(io, "    ", jl_fieldname(field), "::", jltypename(field, p))
        end
    end
    println(io, "end")
end

codegen(io, t::Parsers.GroupType, p::Parsers.ProtoFile) = codegen(io, t.type, p)

function codegen(io, t::Parsers.EnumType, ::Parsers.ProtoFile)
    name = safename(t.name)
    println(io, "@enumx ", name, join(" $k=$n" for (k, n) in zip(keys(t.elements), t.elements)))
end

function codegen(io, t::Parsers.ServiceType, ::Parsers.ProtoFile)
    println(io, "# TODO: SERVICE")
    println(io, "#    ", t)
end

jl_fieldname(f::Parsers.AbstractProtoFieldType) = safename(f.name)
jl_fieldname(f::Parsers.GroupType) = f.field_name

jltypename(f::Parsers.AbstractProtoFieldType, p)  = jltypename(f.type, p)

jltypename(::Parsers.DoubleType, p)      = "Float64"
jltypename(::Parsers.FloatType, p)       = "Float32"
jltypename(::Parsers.Int32Type, p)       = "Int32"
jltypename(::Parsers.Int64Type, p)       = "Int64"
jltypename(::Parsers.UInt32Type, p)      = "UInt32"
jltypename(::Parsers.UInt64Type, p)      = "UInt64"
jltypename(::Parsers.SInt32Type, p)      = "Int32"
jltypename(::Parsers.SInt64Type, p)      = "Int64"
jltypename(::Parsers.Fixed32Type, p)     = "UInt32"
jltypename(::Parsers.Fixed64Type, p)     = "UInt64"
jltypename(::Parsers.SFixed32Type, p)    = "Int32"
jltypename(::Parsers.SFixed64Type, p)    = "Int64"
jltypename(::Parsers.BoolType, p)        = "Bool"
jltypename(::Parsers.StringType, p)      = "String"
jltypename(::Parsers.BytesType, p)       = "Vector{UInt8}"
jltypename(t::Parsers.MessageType, p)    = safename(t.name)
jltypename(t::Parsers.MapType, p)        = string("Dict{", jltypename(t.keytype,p), ',', jltypename(t.valuetype,p), "}")
# TODO: Allow (via options?) to be the parent struct parametrized on the type of OneOf
#       Parent structs should be then be parametrized as well?
function jltypename(t::Parsers.ReferencedType, p) 
    name = safename(t.name)
    isa(get(p.definitions, t.name, nothing), Parsers.EnumType) && return string(name, ".T")
    return name
end
function jltypename(t::Parsers.OneOfType, p)
    union_types = unique!([jltypename(f.type,p) for f in t.fields])
    if length(union_types) > 1
        return string("OneOf{Union{", join(union_types, ','), "}}")
    else
        return string("OneOf{", only(union_types), "}")
    end
end

function translate(path::String, p::Parsers.ProtoFile)
    open(path, "w") do io
        translate(io, p)
    end
end

translate(p::Parsers.ProtoFile) = translate(stdin, p)
function translate(io, p::Parsers.ProtoFile)
    pkg_metadata = Pkg.project()
    println(io, "# Autogenerated using $(pkg_metadata.name).jl v$(pkg_metadata.version) on $(Dates.now())")
    println(io, "# proto", p.preamble.isproto3 ? '3' : '2', " syntax")
    println(io)
    for dependency in translate_import_path(p)
        println(io, "include(", repr(dependency), ")")
    end
    isempty(p.preamble.imports) || println(io)
    println(io, "using ProtocolBuffers: OneOf")
    println(io, "using EnumX: @enumx")
    println(io)
    for def_name in p.sorted_definitions
        println(io)
        codegen(io, p.definitions[def_name], p)
    end
end

end # CodeGenerators